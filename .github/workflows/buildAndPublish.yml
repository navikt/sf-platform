# Workflow: Build and Publish
# Purpose: Builds Salesforce packages, publishes artifacts, generates release files, and creates a GitHub release.
# Triggers: Manual (workflow_dispatch) or push to main with source changes.
# Notes: Skips publishing and release steps if no artifacts are generated during build.
name: "Build and Publish"
on:
  workflow_call:
    secrets:
      SF_DEVHUB_URL:
        required: true
  push:
    branches:
      - main
  workflow_dispatch:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
jobs:
  staticCodeValidation:
    name: Validation jobs
    uses: navikt/sf-platform/.github/workflows/ciStaticCodeValidation.yml@main
    permissions:
      contents: read

  checkChanges:
    name: Check changes
    needs: staticCodeValidation
    runs-on: ubuntu-latest
    outputs:
      hasSrcChanges: ${{ steps.checkChanges.outputs.hasSrcChanges }}
    permissions:
      contents: read
    steps:
      - name: "Checkout"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 0
          persist-credentials: false

      - uses: navikt/sf-platform/.github/actions/checkForPackageChanges@8a76cf6726f88608113bd6cc313b4a6728ce476a
        id: checkChanges

  buildAndPublish:
    name: Build and Publish
    needs: checkChanges
    if: ${{ github.event_name == 'workflow_dispatch' || needs.checkChanges.outputs.hasSrcChanges == 'true' }}
    runs-on: ubuntu-latest
    container: ghcr.io/flxbl-io/sfp:${{ vars.SFP_CONTAINER_VERSION || 'latest' }}
    permissions:
      contents: write
      packages: write
    env:
      SFP_LOG_LEVEL: ${{ vars.SFP_LOG_LEVEL || 'INFO' }}
      NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SCOPE: ${{ github.repository_owner }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Authenticate node
        uses: actions/setup-node@v4
        with:
          registry-url: "https://npm.pkg.github.com"

      - name: Authenticate DevHub
        uses: navikt/sf-platform/.github/actions/authenticateOrg@a0f22eb5d1c9d1ec5e345c04c96a786bd150042a
        with:
          auth-url: ${{ secrets.SF_DEVHUB_URL }}
          alias: "devhub"
          setDefaultDevhubUsername: "true"

      - name: Build
        id: build
        run: |
          if sfp build --devhubalias devhub --diffcheck --buildnumber ${GITHUB_RUN_ID} --branch main --releaseconfig config/releaseConfig.yml --loglevel ${SFP_LOG_LEVEL}; then
            if [ -d "artifacts" ] && [ -n "$(ls -A artifacts)" ]; then
              echo "Artifacts found"
              echo "artifactsFound=true" >> $GITHUB_OUTPUT
            else
              echo "::warning::No artifacts found after running Build step."
              echo "artifactsFound=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "::error::Build command failed"
            echo "artifactsFound=false" >> $GITHUB_OUTPUT
            exit 1  # Fail the job only on build error
          fi

      - name: Publish artifacts
        if: steps.build.outputs.artifactsFound == 'true'
        run: |
          sfp publish --artifactdir artifacts --npm --scope @${SCOPE} --devhubalias devhub --loglevel ${SFP_LOG_LEVEL} --gittag --pushgittag --logsgroupsymbol ::group::,::endgroup::

      - name: Generate Release Name
        if: steps.build.outputs.artifactsFound == 'true'
        id: generate_name
        run: |
          echo "releaseName=sf-platform_$(date +%s%3N)" >> $GITHUB_OUTPUT

      - name: Generate release definition and change log
        if: steps.build.outputs.artifactsFound == 'true'
        id: create_release_files
        run: |
          printf -v red '\033[0;31m'
          printf -v yellow '\033[0;33m'
          printf -v green '\033[0;32m'
          printf -v bold '\033[1m'
          printf -v reset '\033[0m'

          # Debug: Print release name
          echo "${yellow}${bold}Release Name:${reset} ${RELEASE_NAME}"

          # Create the directory for release files
          mkdir -p releases/${RELEASE_NAME}

          echo "${yellow}Generating release definition...${reset}"

          # Generate release definition and save to file
          releaseDefinitionOutput=$(sfp releasedefinition generate \
            --gitref ${GIT_REF} \
            --configfile ${PATH_TO_CONFIG_FILE} \
            --releasename ${RELEASE_NAME} \
            --branchname ${BRANCH_NAME} \
            --loglevel ${SFP_LOG_LEVEL} \
            --nopush)

          echo "$releaseDefinitionOutput"

          echo "$releaseDefinitionOutput" | sed 's/\x1b\[[0-9;]*m//g' \
          | awk '/^release:/,0' > releases/${RELEASE_NAME}/${RELEASE_NAME}.yml

          echo "${yellow}Generating changelog...  ${reset}"

          # Generate changelog
          changelogOutput=$(sfp changelog generate \
            --branchname main \
            --releasename ${RELEASE_NAME} \
            --workitemfilter PTCRM-[0-9] \
            --directory changelog \
            --nopush 2>&1)

          echo "$changelogOutput"
          path=$(echo "$changelogOutput" | grep -oP 'Copying the repository to \K[^ ]+' | head -1)

          # Copy changelog files to release directory
          if [ -n "$path" ] && [ -d "$path/changelog" ]; then
            cp "$path/changelog"/* releases/${RELEASE_NAME}/
          else
            echo "::warning::Path not set or directory does not exist. Tried looking for $path/changelog."
          fi

          files=$(find releases/${RELEASE_NAME} -maxdepth 1 -type f \( -name "*.md" -o -name "*.yml" \) -printf '%p,' | sed 's/,$//')

          # Check if the files was created
          if [ -z "$files" ]; then
            echo "::warning::No files found."
          else
            echo "${yellow}${bold}Files created:${reset}"
            echo "$files"
          fi

          echo "files=$files" >> $GITHUB_OUTPUT

          git config --global --add safe.directory "$GITHUB_WORKSPACE"
        env:
          GIT_REF: ${{ github.sha }}
          PATH_TO_CONFIG_FILE: "config/releaseConfig.yml"
          RELEASE_NAME: ${{ steps.generate_name.outputs.releaseName }}
          BRANCH_NAME: ${{ github.ref_name }}

      - name: Commit release files
        if: steps.build.outputs.artifactsFound == 'true'
        uses: navikt/sf-platform/.github/actions/commitFiles@9bdaa6b47c446ec455e197a69a313fe963f7f6ec
        with:
          files: ${{ steps.create_release_files.outputs.files }}
          commitMessage: "Release files for ${{ steps.generate_name.outputs.releaseName }}"
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Github Release
        if: steps.build.outputs.artifactsFound == 'true'
        run: |
          printf -v red '\033[0;31m'
          printf -v yellow '\033[0;33m'
          printf -v green '\033[0;32m'
          printf -v bold '\033[1m'
          printf -v reset '\033[0m'

          echo "::group::Creating GitHub Release"
          # Prepare the changelog body, preserving Markdown formatting
          changelog_file="releases/${RELEASE_NAME}/Release-Changelog.md"
          if [ -f "$changelog_file" ] && [ -s "$changelog_file" ]; then
            body=$(jq -R -s '.' < "$changelog_file")
          else
            echo "::warning::Changelog file $changelog_file is missing or empty, using default body"
            body=$(jq -R -s '.' <<< "Release ${RELEASE_NAME}")
          fi

          # Construct JSON payload
          json_payload=$(jq -n \
            --arg tag "$RELEASE_NAME" \
            --arg name "$RELEASE_NAME" \
            --argjson body "$body" \
            '{tag_name: $tag, name: $name, body: $body}')

          echo "JSON Payload:"
          echo "$json_payload"

          response=$(curl -s -w "\n%{http_code}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${NODE_AUTH_TOKEN}" \
            -d "$json_payload" \
            https://api.github.com/repos/${{ github.repository }}/releases)

          status=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          echo "HTTP Status: $status"
          echo "Response Body:"
          echo "$body"

          if [ "$status" -ne 201 ]; then
            echo "${red}Failed to create release (HTTP $status)${reset}"
            echo "Response: $body"
            exit 1
          fi

          UPLOAD_URL=$(echo "$body" | jq -r '.upload_url | sub("\\{.*$"; "") // ""')
          if [ -z "$UPLOAD_URL" ]; then
            echo "${red}Failed to extract upload_url from response${reset}"
            echo "Parsed output: $(echo "$body" | jq '.')"
            exit 1
          fi
          echo "Release created successfully. Upload URL: $UPLOAD_URL"
          echo "::endgroup::"

          echo "::group::Uploading Release Files"
          success_count=0
          failure_count=0
          max_retries=2

          # Debug: List files to upload
          echo "Files to upload:"
          ls -l releases/${RELEASE_NAME}/

          for file in releases/${RELEASE_NAME}/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "${yellow}Uploading $filename${reset}"
              attempt=0
              success=false

              while [ $attempt -lt $max_retries ] && [ "$success" = false ]; do
                # Run curl with explicit error handling
                upload_response=$(curl -s -w "\n%{http_code}" \
                  -H "Authorization: token ${NODE_AUTH_TOKEN}" \
                  -H "Content-Type: application/octet-stream" \
                  --data-binary @"$file" \
                  "$UPLOAD_URL?name=$filename" || echo "curl failed with exit code $?"; echo "999")
                upload_status=$(echo "$upload_response" | tail -n1)
                upload_body=$(echo "$upload_response" | sed '$d')

                if [ "$upload_status" -eq 201 ]; then
                  echo "${green}Successfully uploaded $filename (HTTP $upload_status)${reset}"
                  success=true
                  ((success_count++))
                else
                  ((attempt++))
                  echo "${red}Upload attempt $attempt failed for $filename (HTTP $upload_status)${reset}"
                  echo "Upload Response: $upload_body"
                  [ $attempt -lt $max_retries ] && sleep 2
                fi
              done

              if [ "$success" = false ]; then
                echo "::warning::Failed to upload $filename after $max_retries attempts"
                ((failure_count++))
              fi
            else
              echo "Skipping $file - not a regular file"
            fi
          done
          echo "::endgroup::"

          echo "::group::Upload Summary"
          echo "${green}Uploaded ${yellow}${bold}$success_count${reset}${green} files successfully${reset}"
          echo "${red}Failed to upload ${yellow}${bold}$failure_count${reset}${red} files${reset}"
          if [ $failure_count -gt 0 ]; then
            echo "::warning::Some uploads failed, check logs for details"
          fi
          if [ $success_count -eq 0 ] && [ $failure_count -gt 0 ]; then
            echo "::error::${red}No files uploaded successfully${reset}"
            exit 1
          fi
          echo "::endgroup::"
        env:
          RELEASE_NAME: ${{ steps.generate_name.outputs.releaseName }}

      - name: Upload artifacts and logs
        if: steps.build.outputs.artifactsFound == 'true'
        uses: navikt/sf-platform/.github/actions/uploadWorkflowArtifactsAndLogs@f318a266c5a7add9c091f9d3480164fed8abfc08
        with:
          artifactName: "build-artifacts"
          uploadArtifacts: true
          logName: "build-logs"
          publishLogs: true
